df_prefix = df_prefix,
viewname = "auto-decomposition-2",
title = "Auto Test Diagram",
targetConcept = c("mission:Component"),
targetRelation = "base:isContainedIn",
nodeColor = "seablue",
nodeTextColor = "white")
df_keys <- omlvisionDecomposition(omlrepo = omlrepo,
df_prefix = df_prefix,
viewname = "auto-decomposition-2",
title = "Auto Test Diagram",
targetConcept = c("mission:Component"),
targetRelation = "base:isContainedIn",
nodeColor = "Sea Blue",
nodeTextColor = "white")
df_keys <- omlvisionDecomposition(omlrepo = omlrepo,
df_prefix = df_prefix,
viewname = "auto-decomposition-2",
title = "Auto Test Diagram",
targetConcept = c("mission:Component"),
targetRelation = "base:isContainedIn",
nodeColor = "#006994",
nodeTextColor = "white")
#| warning: false
source("omlvision_wrapper.R")
searchDirectory <- function(iteration, pattern, parent_directory){
for(i in 1:iteration){
path <- list.files(parent_directory, recursive = TRUE, pattern = pattern, full.names = TRUE)
if(length(path)){
return(path)
}
parent_directory <- dirname(parent_directory)
}
print("file not found")
return(path)
}
source(searchDirectory(4, "osr_common.R", (getwd())))
omlrepo
df_prefix <- data.frame(
prefix = c("base",
"mission"),
iri = c("http://imce.jpl.nasa.gov/foundation/base#",
"http://imce.jpl.nasa.gov/foundation/mission#",
"http://example.com/tutorial2/vocabulary/stateanalysis#")
)
df_prefix <- data.frame(
prefix = c("base",
"mission",
"sa"),
iri = c("http://imce.jpl.nasa.gov/foundation/base#",
"http://imce.jpl.nasa.gov/foundation/mission#",
"http://example.com/tutorial2/vocabulary/stateanalysis#")
)
query_string <- generatePrefix(df_prefix)
cat(query_string)
df_keys <- omlvisionRelationMap(omlrepo = omlrepo,
df_prefix = df_prefix,
viewname = "auto-state-effect-diagram",
title = "Auto State Effect Diagram",
targetConcept = c("sa:StateVariable"),
targetRelation = "sa:affects",
nodeColor = "#006994",
nodeTextColor = "white")
df_keys <- omlvisionRelationMap(omlrepo = omlrepo,
df_prefix = df_prefix,
viewname = "auto-state-effect-diagram",
title = "Auto State Effect Diagram",
targetConcept = c("sa:StateVariable"),
targetRelation = "sa:affects",
nodeColor = "#006994",
nodeTextColor = "white")
#| warning: false
source("omlvision_wrapper.R")
searchDirectory <- function(iteration, pattern, parent_directory){
for(i in 1:iteration){
path <- list.files(parent_directory, recursive = TRUE, pattern = pattern, full.names = TRUE)
if(length(path)){
return(path)
}
parent_directory <- dirname(parent_directory)
}
print("file not found")
return(path)
}
source(searchDirectory(4, "osr_common.R", (getwd())))
omlrepo
df_prefix <- data.frame(
prefix = c("base",
"mission",
"sa"),
iri = c("http://imce.jpl.nasa.gov/foundation/base#",
"http://imce.jpl.nasa.gov/foundation/mission#",
"http://example.com/tutorial2/vocabulary/stateanalysis#")
)
query_string <- generatePrefix(df_prefix)
cat(query_string)
df_keys <- omlvisionRelationMap(omlrepo = omlrepo,
df_prefix = df_prefix,
viewname = "auto-state-effect-diagram",
title = "Auto State Effect Diagram",
targetConcept = c("sa:StateVariable"),
targetRelation = "sa:affects",
nodeColor = "#006994",
nodeTextColor = "white")
df_keys <- omlvisionRelationMap(omlrepo = omlrepo,
df_prefix = df_prefix,
viewname = "auto-state-effect-diagram-2",
title = "Auto State Effect Diagram 2",
targetConcept = c("sa:StateVariable"),
targetRelation = "sa:affects",
nodeColor = "#006994",
nodeTextColor = "white")
df_prefix <- data.frame(
prefix = c("base",
"mission",
"project",
"analysis"),
iri = c("http://imce.jpl.nasa.gov/foundation/base#",
"http://imce.jpl.nasa.gov/foundation/mission#",
"http://imce.jpl.nasa.gov/foundation/analysis#",
"http://imce.jpl.nasa.gov/foundation/project#"
)
)
cat(df_prefix)
query_string <- generatePrefix(df_prefix)
cat(query_string)
cat(generatePrefix(df_prefix))
#| warning: false
searchDirectory <- function(iteration, pattern, parent_directory){
for(i in 1:iteration){
path <- list.files(parent_directory, recursive = TRUE, pattern = pattern, full.names = TRUE)
if(length(path)){
return(path)
}
parent_directory <- dirname(parent_directory)
}
print("file not found")
return(path)
}
source(searchDirectory(4, "osr_common.R", (getwd())))
source(searchDirectory(4, "massRollupKepler16b.R", (getwd())))
library(reticulate)
# use_condaenv("py393")
use_python("/Users/mlab/opt/anaconda3/envs/py393/bin/python")
library(tansakusuR)
endpoint_url <- "http://localhost:3030/tutorial2/sparql"
configuration_root_iri <- "http://example.com/tutorial2/description/components#orbiter-spacecraft"
query_string <- '
PREFIX mission:     <http://imce.jpl.nasa.gov/foundation/mission#>
PREFIX base:        <http://imce.jpl.nasa.gov/foundation/base#>
PREFIX project:     <http://imce.jpl.nasa.gov/foundation/project#>
PREFIX vim4:		<http://bipm.org/jcgm/vim4#>
SELECT DISTINCT ?c1 ?c1_instancename ?c1_id ?c1_name ?c1_mass ?c2 ?c2_instancename ?c2_id ?c2_name ?c2_mass ?c3 ?c3_instancename ?c3_id ?c3_name ?c4
WHERE {
VALUES ?c1 { <$configuration_root_iri> }
OPTIONAL{
?c1 base:hasIdentifier ?c1_id ;
base:hasCanonicalName ?c1_name ;
}
OPTIONAL {
?c1_mass_mag vim4:characterizes ?c1 ;
vim4:hasDoubleNumber ?c1_mass .
}
OPTIONAL{
?c1 base:contains ?c2 ;
OPTIONAL{
?c2 base:hasIdentifier ?c2_id ;
base:hasCanonicalName ?c2_name .
}
OPTIONAL {
?c2_mass_mag vim4:characterizes ?c2 ;
vim4:hasDoubleNumber ?c2_mass .
}
OPTIONAL{
?c2 project:isSuppliedBy ?c3 ;
OPTIONAL{
?c3 base:hasIdentifier ?c3_id ;
base:hasCanonicalName ?c3_name;
project:isAuthorizedBy ?c4 .
}
}
}
BIND(STRAFTER(STR(?c1), "#") AS ?c1_instancename) .
BIND(STRAFTER(STR(?c2), "#") AS ?c2_instancename) .
BIND(STRAFTER(STR(?c3), "#") AS ?c3_instancename) .
}
ORDER BY ?c2_id
'
library(stringr)
query_string <- str_replace(query_string, "\\$configuration_root_iri", configuration_root_iri)
df_query <- send_query(endpoint_url,query_string)
df_parameters <- data.frame(
initOrbit = 0.0,
targetOrbit = 0.0,
m_wet = 0.0,
m_dry = 0.0,
m_fuel = 0.0,
dv = 0.0
)
df_parameters$m_dry <- 325.47880079
df_parameters$initOrbit <- 400
df_parameters$targetOrbit <- 35786
df_parameters$I_sp <- 350
# initOrbit <- 400
# targetOrbit <- 35786
# m_dry <- 325.47880079
# I_sp <- 300
df_query$c1_type <- "component"
df_query <- df_query %>%
mutate(c2_label = paste0(c2_id,": ",c2_instancename)) %>%
mutate(c1_label = paste0(c1_id,": ",c1_instancename))
df_config <- df_query
# just for vis add NA to root
df_vis <- df_config %>%
add_row(c1=NA,
c1_instancename=NA,
c1_id=NA,
c1_name=NA,
c1_mass=NA,
c2=df_config$c1[1],
c2_instancename=df_config$c1_instancename[1],
c2_id=df_config$c1_id[1],
c2_name=df_config$c1_name[1],
c2_mass=df_config$c1_mass[1],
c1_type=df_config$c1_type[1],
c2_label=NA,
c1_label=df_config$c1_label[1],
.before = 1)
plotCollapsibleTreeFromDataframe(df_vis, palette="BluYl",
parent="c2_label",
child="c1_label",
type="c2_id")
library(igraph)
df_g <- df_config %>%
mutate(parent = c1_instancename) %>%
mutate(child = c2_instancename) %>%
mutate(type = c2_instancename) %>%
# mutate(parent = paste0(p_id, ": ", p_instancename)) %>%
# mutate(child = paste0(c_id, ": ", c_instancename)) %>%
select("parent","child","type")
# df_g <- df_g[-1,]
g <- graph_from_data_frame(df_g,
directed = TRUE,
vertices = NULL)
root <- V(g)[1]
# Depth-first search is an algorithm to traverse a graph. It starts from a root vertex and tries to go quickly as far from as possible.
order <- dfs(g, V(g)[root], order.out = TRUE)$order
df_mel_before <- igraph::as_data_frame(g, what = "vertices") %>%
arrange(factor(name, levels = names(order)))%>%
filter(name !="NA")
# ここに、df_mass として massの値を入れたコンフィグを作る必要がある。
df_mass <-  df_config
df_mass <-  df_mass %>%
mutate(mass = as.numeric(c2_mass)) %>%
select(c2,
c2_instancename,
c2_id,
c2_name,
c1_id,
mass) %>%
add_row(c2=df_mass$c1[1],
c2_instancename=df_mass$c1_instancename[1],
c2_id=df_mass$c1_id[1],
c2_name=df_mass$c1_name[1],
c1_id=NA,
mass=as.numeric(df_mass$c1_mass[1]),
.before = 1)%>%
arrange(c2_id)
colnames(df_mass) <- c("c_iri","c_instancename","c_id","c_name", "p_id", "mass")
df_mel_before <- left_join(df_mel_before, df_mass, by = c("name"="c_instancename"))
namekey="name"
masskey="mass"
df_mass_update <- massRollUp(g, root, df_mel_before, namekey = "name",masskey = "mass") %>%
select(name, mass)
# リーフ数を取得
df_deg <- data.frame(
name = names(degree(g)),
degree = degree(g)-1, # num of components is degree(g)-1
distance = distances(g)[V(g)[1],]
)
# distanceの値で、componentか、workpackageかを切り分けることができる
df_mel_after <- df_mel_before %>% select(-mass)
df_mel_after <- left_join(df_mel_after, df_mass_update, by=c("name"="name"))
df_mel_after <- left_join(df_mel_after, df_deg, by=c("name"="name"))
df_mel_after$componenttype <- ifelse(df_mel_after$distance == 0, "system",
ifelse(df_mel_after$distance == 1, "subsystem",
ifelse(df_mel_after$distance == 2, "assembly", NA)))
library(reactable)
df_table <- df_mel_after %>%
mutate(totalmass=mass) %>%
select(c_id, name, totalmass, componenttype)
df_table$componenttype <- factor(df_table$componenttype)
datatable(df_table, options = list(autoWidth = TRUE, pageLength = -1), filter = list(
position = 'top', clear = FALSE
))
df_parameters$m_dry <- df_mel_after$mass[1]
df_parameters$m_dry <- 325.47880079
reticulate::repl_python()
df_parameters$dv <- py$total_delta_v /1000.0 # km/s
source(searchDirectory(4, "calcWetMass.R", (getwd())))
# I_sp <- 350
# m_dry <- 325.47880079
# df_parameters$dv <- sum(df_parameters$dv)
# Inverse Problem
df_parameters$m_wet <- calcWetMass(df_parameters$dv, df_parameters$m_dry, df_parameters$I_sp)
df_parameters$m_fuel <- df_parameters$m_wet - df_parameters$m_dry
c(df_parameters$m_wet, df_parameters$m_dry, df_parameters$m_fuel)
df_table <- df_parameters %>%
mutate(id=1) %>%
pivot_longer(!id, names_to = "parameter", values_to = "value") %>%
select(-id)
datatable(df_table, options = list(autoWidth = TRUE, pageLength = -1))
df_parameters2 <- data.frame(
parameter = c("initOrbit","targetOrbit","I_sp","m_dry","m_fuel","m_wet","dv"),
value = c(400,35786,350,
df_parameters$m_dry,
df_parameters$m_fuel,
df_parameters$m_wet,
df_parameters$dv),
type = c("input","input","input","output","input","output","output")
)
# how to access data
df_parameters2$value[df_parameters2$parameter == "m_dry"]
reticulate::repl_python()
df_parameters$m_dry <- df_mel_after$mass[1]
# df_parameters$m_dry <- 325.47880079
#| warning: false
searchDirectory <- function(iteration, pattern, parent_directory){
for(i in 1:iteration){
path <- list.files(parent_directory, recursive = TRUE, pattern = pattern, full.names = TRUE)
if(length(path)){
return(path)
}
parent_directory <- dirname(parent_directory)
}
print("file not found")
return(path)
}
source(searchDirectory(4, "osr_common.R", (getwd())))
source(searchDirectory(4, "massRollupKepler16b.R", (getwd())))
library(reticulate)
# use_condaenv("py393")
use_python("/Users/mlab/opt/anaconda3/envs/py393/bin/python")
library(tansakusuR)
endpoint_url <- "http://localhost:3030/tutorial2/sparql"
configuration_root_iri <- "http://example.com/tutorial2/description/components#orbiter-spacecraft"
query_string <- '
PREFIX mission:     <http://imce.jpl.nasa.gov/foundation/mission#>
PREFIX base:        <http://imce.jpl.nasa.gov/foundation/base#>
PREFIX project:     <http://imce.jpl.nasa.gov/foundation/project#>
PREFIX vim4:		<http://bipm.org/jcgm/vim4#>
SELECT DISTINCT ?c1 ?c1_instancename ?c1_id ?c1_name ?c1_mass ?c2 ?c2_instancename ?c2_id ?c2_name ?c2_mass ?c3 ?c3_instancename ?c3_id ?c3_name ?c4
WHERE {
VALUES ?c1 { <$configuration_root_iri> }
OPTIONAL{
?c1 base:hasIdentifier ?c1_id ;
base:hasCanonicalName ?c1_name ;
}
OPTIONAL {
?c1_mass_mag vim4:characterizes ?c1 ;
vim4:hasDoubleNumber ?c1_mass .
}
OPTIONAL{
?c1 base:contains ?c2 ;
OPTIONAL{
?c2 base:hasIdentifier ?c2_id ;
base:hasCanonicalName ?c2_name .
}
OPTIONAL {
?c2_mass_mag vim4:characterizes ?c2 ;
vim4:hasDoubleNumber ?c2_mass .
}
OPTIONAL{
?c2 project:isSuppliedBy ?c3 ;
OPTIONAL{
?c3 base:hasIdentifier ?c3_id ;
base:hasCanonicalName ?c3_name;
project:isAuthorizedBy ?c4 .
}
}
}
BIND(STRAFTER(STR(?c1), "#") AS ?c1_instancename) .
BIND(STRAFTER(STR(?c2), "#") AS ?c2_instancename) .
BIND(STRAFTER(STR(?c3), "#") AS ?c3_instancename) .
}
ORDER BY ?c2_id
'
library(stringr)
query_string <- str_replace(query_string, "\\$configuration_root_iri", configuration_root_iri)
df_query <- send_query(endpoint_url,query_string)
df_parameters <- data.frame(
initOrbit = 0.0,
targetOrbit = 0.0,
m_wet = 0.0,
m_dry = 0.0,
m_fuel = 0.0,
dv = 0.0
)
df_parameters$m_dry <- 325.47880079
df_parameters$initOrbit <- 400
df_parameters$targetOrbit <- 35786
df_parameters$I_sp <- 350
# initOrbit <- 400
# targetOrbit <- 35786
# m_dry <- 325.47880079
# I_sp <- 300
df_query$c1_type <- "component"
df_query <- df_query %>%
mutate(c2_label = paste0(c2_id,": ",c2_instancename)) %>%
mutate(c1_label = paste0(c1_id,": ",c1_instancename))
df_config <- df_query
# just for vis add NA to root
df_vis <- df_config %>%
add_row(c1=NA,
c1_instancename=NA,
c1_id=NA,
c1_name=NA,
c1_mass=NA,
c2=df_config$c1[1],
c2_instancename=df_config$c1_instancename[1],
c2_id=df_config$c1_id[1],
c2_name=df_config$c1_name[1],
c2_mass=df_config$c1_mass[1],
c1_type=df_config$c1_type[1],
c2_label=NA,
c1_label=df_config$c1_label[1],
.before = 1)
plotCollapsibleTreeFromDataframe(df_vis, palette="BluYl",
parent="c2_label",
child="c1_label",
type="c2_id")
library(igraph)
df_g <- df_config %>%
mutate(parent = c1_instancename) %>%
mutate(child = c2_instancename) %>%
mutate(type = c2_instancename) %>%
# mutate(parent = paste0(p_id, ": ", p_instancename)) %>%
# mutate(child = paste0(c_id, ": ", c_instancename)) %>%
select("parent","child","type")
# df_g <- df_g[-1,]
g <- graph_from_data_frame(df_g,
directed = TRUE,
vertices = NULL)
root <- V(g)[1]
# Depth-first search is an algorithm to traverse a graph. It starts from a root vertex and tries to go quickly as far from as possible.
order <- dfs(g, V(g)[root], order.out = TRUE)$order
df_mel_before <- igraph::as_data_frame(g, what = "vertices") %>%
arrange(factor(name, levels = names(order)))%>%
filter(name !="NA")
# ここに、df_mass として massの値を入れたコンフィグを作る必要がある。
df_mass <-  df_config
df_mass <-  df_mass %>%
mutate(mass = as.numeric(c2_mass)) %>%
select(c2,
c2_instancename,
c2_id,
c2_name,
c1_id,
mass) %>%
add_row(c2=df_mass$c1[1],
c2_instancename=df_mass$c1_instancename[1],
c2_id=df_mass$c1_id[1],
c2_name=df_mass$c1_name[1],
c1_id=NA,
mass=as.numeric(df_mass$c1_mass[1]),
.before = 1)%>%
arrange(c2_id)
colnames(df_mass) <- c("c_iri","c_instancename","c_id","c_name", "p_id", "mass")
df_mel_before <- left_join(df_mel_before, df_mass, by = c("name"="c_instancename"))
namekey="name"
masskey="mass"
df_mass_update <- massRollUp(g, root, df_mel_before, namekey = "name",masskey = "mass") %>%
select(name, mass)
# リーフ数を取得
df_deg <- data.frame(
name = names(degree(g)),
degree = degree(g)-1, # num of components is degree(g)-1
distance = distances(g)[V(g)[1],]
)
# distanceの値で、componentか、workpackageかを切り分けることができる
df_mel_after <- df_mel_before %>% select(-mass)
df_mel_after <- left_join(df_mel_after, df_mass_update, by=c("name"="name"))
df_mel_after <- left_join(df_mel_after, df_deg, by=c("name"="name"))
df_mel_after$componenttype <- ifelse(df_mel_after$distance == 0, "system",
ifelse(df_mel_after$distance == 1, "subsystem",
ifelse(df_mel_after$distance == 2, "assembly", NA)))
library(reactable)
df_table <- df_mel_after %>%
mutate(totalmass=mass) %>%
select(c_id, name, totalmass, componenttype)
df_table$componenttype <- factor(df_table$componenttype)
datatable(df_table, options = list(autoWidth = TRUE, pageLength = -1), filter = list(
position = 'top', clear = FALSE
))
df_parameters$m_dry <- df_mel_after$mass[1]
# df_parameters$m_dry <- 325.47880079
reticulate::repl_python()
df_parameters$dv <- py$total_delta_v /1000.0 # km/s
source(searchDirectory(4, "calcWetMass.R", (getwd())))
# I_sp <- 350
# m_dry <- 325.47880079
# df_parameters$dv <- sum(df_parameters$dv)
# Inverse Problem
df_parameters$m_wet <- calcWetMass(df_parameters$dv, df_parameters$m_dry, df_parameters$I_sp)
df_parameters$m_fuel <- df_parameters$m_wet - df_parameters$m_dry
c(df_parameters$m_wet, df_parameters$m_dry, df_parameters$m_fuel)
df_table <- df_parameters %>%
mutate(id=1) %>%
pivot_longer(!id, names_to = "parameter", values_to = "value") %>%
select(-id)
datatable(df_table, options = list(autoWidth = TRUE, pageLength = -1))
reticulate::repl_python()
